thing <- complete("specdata")
nitrates <- data.frame()
sulfates <- data.frame()
for (i in 1:332) {
if(thing[i, "nobs"] > threshold) {
one <- read.csv(files[i])
two <- complete.cases(one)
nitrates <- rbind(nitrates, one[two, "nitrate"])
sulfates <- rbind(sulfates, one[two, "sulfate"])
} else {
emptty <- numeric()
emptty
}
}
cor(nitrates, sulfates)
}
cr <- corr("specdata", 150)
head(cr)
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.names = TRUE)
thing <- complete("specdata")
nitrates <- data.frame()
sulfates <- data.frame()
for (i in 1:332) {
if(thing[i, "nobs"] > threshold) {
one <- read.csv(files[i])
two <- complete.cases(one)
nitrates <- cbind(nitrates, one[two, "nitrate"])
sulfates <- cbind(sulfates, one[two, "sulfate"])
} else {
emptty <- numeric()
emptty
}
}
cor(nitrates, sulfates)
}
cr <- corr("specdata", 150)
files <- list.files(directory, full.names = TRUE)
files <- list.files("specdata", full.names = TRUE)
head(files)
thing <- complete("specdata")
head(thing)
nitrates <- data.frame()
one <- read.csv(files[1])
head(one)
two <- complete.cases(one)
one[two, "nitrate"]
nitrates <- cbind(nitrates, one[two, "nitrate"])
head(two)
nitrates <- cbind(nitrates, one[two == TRUE, "nitrate"])
?nrow
rowss <- one[which(two == TRUE)]
rowss <- one[which(two == TRUE), ]
rows
rowss
nitrates <- cbind(nitrates, one[rowss, "nitrate"])
one[rowss, "nitrate"]
one[rowss, nitrate]
one[rowss]
one[which(two == TRUE), "nitrate"]
three <- one[which(two == TRUE), "nitrate"]
nitrates <- cbind(nitrates, one$nitrate)
nitrates <- rbind(nitrates, one$nitrate)
nitrates
?data.frame()
?matrix()
one[two, "nitrate"]
nitrates <- matrix(one[two, "nitrate"])
nitrates
nitrates <- matrix
nitrates <- matrix()
nitrates <- cbind(nitrates, one[two, "nitrate"])
?cbind
nitrates <- rbind(nitrates, one[two, "nitrate"])
head(one$nitrate)
head(two)
head(three)
nit <- matrix(three)
nit
nit <- rbind(nit, three)
nit <- cbind(nit, three)
dat <- data.frame(ncol = 2)
dat
?data.frame
dat <- data.frame(1, 2)
dat
dat <- data.frame()
dat
source("complete.R")
files <- list.files(directory, full.names = TRUE)
files <- list.files("specdata", full.names = TRUE)
one <- read.csv(files[1])
head(1)
head(one)
dat <- cbind(one$nitrate)
dat
dat <- cbind(one$nitrate(which(complete.cases(one) == TRUE)))
dat <- cbind(one$nitrate[which(complete.cases(one) == TRUE)])
dat
dat <- rbind(one$nitrate[which(complete.cases(one) == TRUE)])
dat
dat <- data.frame()
dat <- cbind(one$nitrate[which(complete.cases(one) == TRUE)])
dat <- cbind(one$nitrate[which(complete.cases(one) == TRUE)])
dat
dat <- cbind(one$sulfate[which(complete.cases(one) == TRUE)])
dat
dat <- cbind(one$nitrate[which(complete.cases(one) == TRUE)])
dat <- cbind(dat, one$nitrate[which(complete.cases(one) == TRUE)])
dat
dat <- cbind(dat, one$sulfate[which(complete.cases(one) == TRUE)])
dat
cor(dat[, 2], dat[, 3])
dat <- data.frame()
dat <- cbind(dat, one$nitrate[which(complete.cases(one) == TRUE)])
dat <- data.frame()
datone <- read.csv(files[1])
dat <- cbind(one$nitrate[which(complete.cases(one) == TRUE)])
dat
tempdat <- data.frame()
tempdat <- cbind(datone$nitrate, datone$sulfate)
head(tempdat)
dat <- data.frame()
?colnames()
colnames(dat) <- c("nitrate", "sulfate")
??ncol
dat <- matrix(ncol = 2)
dat
dat <- cbind(dat, one$nitrate[which(complete.cases(one) == TRUE)])
dat <- cbind(dat, one$nitrate[which(complete.cases(one) == TRUE)], one$nitrate[which(complete.cases(one) == TRUE)])
tempdat <- matrix(one$nitrate, one$sulfate)
tempdat <- matrix(one$nitrate[which(complete.cases(one) == TRUE)])
head(tempdat)
tempdat <- cbind(one$sulfate[which(complete.cases(one) == TRUE)])
head(tempdat)
tempdat <- matrix(one$nitrate[which(complete.cases(one) == TRUE)])
tempdat <- cbind(tempdat, one$sulfate[which(complete.cases(one) == TRUE)])
head(tempdat)
subset(one, select = c("nitrate", "sulfate"))
?subset
two <- one[which(complete.cases(one) == TRUE)]
two <- one[which(complete.cases(one) == TRUE), ]
head(two)
three <- subset(two, select = c("nitrate", "sulfate"))
head(three)
dat <- data.frame()
dat <- cbind(dat, three)
class(three)
dat <- rbind(dat, three)
dat
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.names = TRUE)
thing <- complete("specdata")
dat <- data.frame()
for (i in thing$id) {
if(thing[i, "nobs"] > threshold) {
one <- read.csv(files[i])
two <- one[which(complete.cases(one) == TRUE), ]
three <- subset(two, select = c("nitrate", "sulfate"))
dat <- rbind(dat, three)
} else {
emptty <- numeric()
emptty
}
}
cor(dat$nitrate, dat$sulfate)
}
cr <- corr("specdata", 150)
head(cr)
summary(cr)
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.names = TRUE)
thing <- complete("specdata")
dat <- data.frame()
for (i in thing$id) {
if(thing[i, "nobs"] > threshold) {
one <- read.csv(files[i])
two <- one[which(complete.cases(one) == TRUE), ]
three <- subset(two, select = c("nitrate", "sulfate"))
dat <- rbind(dat, three)
cor(dat$nitrate, dat$sulfate)
} else {
emptty <- numeric()
emptty
}
}
}
cr <- corr("specdata", 150)
head(cr)
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.names = TRUE)
thing <- complete("specdata")
dat <- data.frame()
for (i in 1:332) {
if(thing[i, "nobs"] > threshold) {
one <- read.csv(files[i])
two <- one[which(complete.cases(one) == TRUE), ]
three <- subset(two, select = c("nitrate", "sulfate"))
dat <- rbind(dat, three)
cor(dat$nitrate, dat$sulfate)
} else {
emptty <- numeric()
emptty
}
}
}
cr <- corr("specdata", 150)
head(cr)
correl <- numeric()
correl
correl <- append(correl, 1)
correl
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.names = TRUE)
thing <- complete("specdata")
dat <- data.frame()
correl <- numeric()
for (i in 1:332) {
if(thing[i, "nobs"] > threshold) {
one <- read.csv(files[i])
two <- one[which(complete.cases(one) == TRUE), ]
three <- subset(two, select = c("nitrate", "sulfate"))
dat <- rbind(dat, three)
correl <- append(correl, cor(dat$nitrate, dat$sulfate))
} else {
emptty <- numeric()
emptty
}
}
correl
}
cr <- corr("specdata", 150)
head(cr)
summary(cr)
head(cr)
cr <- corr("specdata", 400)
head(cr)
cr <- corr("specdata")
summary(cr)
length(cr)
?cor
corr <- function(directory, threshold = 0) {
files <- list.files(directory, full.names = TRUE)
thing <- complete("specdata")
dat <- data.frame()
correl <- numeric()
for (i in 1:332) {
if(thing[i, "nobs"] > threshold) {
one <- read.csv(files[i])
two <- subset(one, select = c("nitrate", "sulfate"))
correl <- append(correl, cor(two$nitrate, two$sulfate, use = "pairwise.complete.obs"))
} else {
emptty <- numeric()
}
}
correl
}
cr <- corr("specdata", 150)
head(cr)
summary(cr)
cr <- corr("specdata", 400)
head(cr)
summary(cr)
cr <- corr("specdata", 5000)
summary(cr)
head(cr)
length(cr)
cr <- corr("specdata")
summary(cr)
length(cr)
cr
source("http://d396qusza40orc.cloudfront.net/rprog%2Fscripts%2Fsubmitscript1.R")
submit()
2
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
submit()
x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean)
?gl()
library(swirl)
swirl()
head(flags)
dim(flags)
viewinfo(flags)
viewinfo()
class(flags)
cls_list <- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
cls_vect <- sapply(flags, class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[, 11:17]
head(flag_colors)
lapply(flag_colors, sum)
sapply(flag_colors, sum)
sapply(flag_colors, mean)
flag_shapes <- flags[, 19:23]
lapply(flag_shapes, range)
shape_mat <- sapply(flag_shapes, range)
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
unique_vals <- lapply(flags, unique)
unique_vals
lapply(unique_vals, length)
sapply(unique_vals, length)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
sapply(flags, unique)
vapply(flags, unique, numeric(1))
ok()
sapply(flags, class)
vapply(flags, class, character(1))
?tapply
table(flags$landmass)
?table()
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
log(-1)
library(datasets)
data(iris)
tapply(iris$Sepal.Length, iris$Species, mean)
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
bigVec <- makeVector(1:1000)
biggerVec <- makeVector(1:100000)
cachemean(bigVec)
cachemean(bigVec)
cachemean(biggerVec)
cachemean(biggerVec)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setsolve <- function(solve) i <<- solve
getsolve <- function() i
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, ...) {
i <- x$getsolve()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setsolve(i)
i
}
makeCacheMatrix <- function(matrix(c(4, 3, 3, 2), 2, 2))
?matrix
matriss <- matrix(c(4, 3, 3, 2))
matriss
matriss <- matrix(c(4, 3, 3, 2), 2, 2)
matriss
makeCacheMatrix <- function(matrix(c(4, 3, 3, 2), 2,2))
makeCacheMatrix(c(4, 3, 3, 2), 2, 2)
makeCacheMatrix(matrix(c(4, 3, 3, 2), 2, 2))
matriss <- makeCacheMatrix(matrix(c(4, 3, 3, 2), 2, 2))
cacheSolve(matriss)
matriss <- makeCacheMatrix(matrix(c(1, 3, 2, 4), 2, 2))
cacheSolve(matriss)
cacheSolve(matriss)
new <- matrix(c(4, 3, 3, 2), 2, 2)
cacheSolve(new)
new
cacheSolve(new)
makeCacheMatrix <- function(x = matrix()) {       # Input 'x' will be a matrix.
inv <- NULL                                 # 'inv' will be the inverse;
# 'inv' will be reset every time this function is called.
set <- function(y) {                        # Used by cacheSolve(), it takes an input 'y' and:
x <<- y                               # saves the input;
inv <<- NULL                          # resets the inverse.
}
get <- function() x                         # Returns the value of the original matrix.
setsolve <- function(solve) inv <<- solve   # This will set and store the inverse of the matrix
# the first time cacheSolve() is called for a new matrix.
getsolve <- function() inv                  # Returns the cached value of the inverse when cacheSolve()
# is called the subsequent times for the same matrix.
list(set = set, get = get,                  # List of methods accessed each time the makeCacheMatrix function
setsolve = setsolve,                   # is called. It is here so the calling function will know how to
getsolve = getsolve)                   # access these methods.
}
cacheSolve <- function(x, ...) {                  # Takes 'x' as an input.
inv <- x$getsolve()                         # Gets the inverse of 'x'.
if(!is.null(inv)) {                         # If the inverse is cached, it'll send the message and return the
message("getting cached data")        # inverse.
return(inv)                           # return() will also end the function cacheSolve, so the next part
}                                           # of the code isn't executed.
# If the inverse is not cached, the function will skip to this part.
data <- x$get()                             # This will get the original vector.
inv <- solve(data, ...)                     # Calculates the inverse using the original vector.
x$setsolve(inv)                             # Stores the calculated inverse in 'x'.
inv                                         # Returns the inverse.
}
makeCacheMatrix(new)
wopp <- makeCacheMatrix(new)
cacheSolve(new)
cacheSolve(wopp)
cacheSolve(wopp)
cacheSolve(matriss)
makeCacheMatrix <- function(x = matrix()) {       # Input 'x' will be a matrix.
inv <- NULL                                 # 'inv' will be the inverse;
# 'inv' will be reset every time this function is called.
set <- function(y) {                        # Used by cacheSolve(), it takes an input 'y' and:
x <<- y                               # saves the input;
inv <<- NULL                          # resets the inverse.
}
get <- function() x                         # Returns the value of the original matrix.
setsolve <- function(solve) inv <<- solve   # This will set and store the inverse of the matrix
# the first time cacheSolve() is called for a new matrix.
getsolve <- function() inv                  # Returns the cached value of the inverse when cacheSolve()
# is called the subsequent times for the same matrix.
list(set = set, get = get,                  # List of methods accessed each time the makeCacheMatrix function
setsolve = setsolve,                   # is called. It is here so the calling function will know how to
getsolve = getsolve)                   # access these methods.
}
cacheSolve <- function(x, ...) {                  # Takes 'x' as an input.
inv <- x$getsolve()                         # Gets the inverse of 'x'.
if(!is.null(inv)) {                         # If the inverse is cached, it'll send the message and return the
message("getting cached data")        # inverse.
return(inv)                           # return() will also end the function cacheSolve, so the next part
}                                           # of the code isn't executed.
# If the inverse is not cached, the function will skip to this part.
data <- x$get()                             # This will get the original vector.
inv <- solve(data, ...)                     # Calculates the inverse using the original vector.
x$setsolve(inv)                             # Stores the calculated inverse in 'x'.
inv                                         # Returns the inverse.
}
coiso <- makeCacheMatrix(matrix(c(4, 3, 3, 2), 2, 2))
class(coiso)
summary(coiso)
dim(coiso)
coiso
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setsolve <- function(solve) {
inv <<- solve
}
getsolve <- function() {inv}
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, ...) {
inv <- x$getsolve()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setsolve(inv)
inv
}
source("cachematrix.R")
setwd("ProgrammingAssignment2")
source("cachematrix.R")
amatrix <- makeCacheMatrix(matrix(c(1, 2, 3, 4), 2, 2))
amatrix$get()
cacheSolve(amatrix)
amatrix$getinverse()
cacheSolve(amatrix)
amatrix$set(matrix(c(0,5,99,66), nrow=2, ncol=2))
cacheSolve(amatrix)
amatrix$get()
amatrix$getinverse()
